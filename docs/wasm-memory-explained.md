# WASM Linear Memory 入門

このドキュメントでは、WASMのメモリモデルと現状のサンプラーアーキテクチャを初心者向けに解説する。

---

## 1. Linear Memory とは何か

### 普通のプログラムのメモリ

普通のC++やRustプログラムは、OSから自由にメモリを借りられる:

```
┌─────────────────────────────────────────────────────┐
│                      OS                              │
│  「メモリください」→ はいどうぞ (malloc/new)        │
│  「もっとください」→ はいどうぞ                     │
│  「返します」→ OK (free/delete)                     │
└─────────────────────────────────────────────────────┘
```

### WASMのメモリ (Linear Memory)

WASMは**サンドボックス**で動く。OSに直接アクセスできない。

代わりに、**1本の巨大なバイト配列**が与えられる。これが **Linear Memory**:

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Linear Memory                                │
│                                                                      │
│   ただの巨大なバイト配列 (例: 128MB)                                │
│                                                                      │
│   [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] ... [134217727]           │
│                                                                      │
│   ↑ インデックス (オフセット) でアクセス                            │
└─────────────────────────────────────────────────────────────────────┘
```

**重要なポイント:**
- WASMモジュール (MoonBit) は、この配列の**どこにでも**読み書きできる
- Host (C++/JS) も、この配列の**どこにでも**読み書きできる
- **同じメモリを共有している**

---

## 2. 誰が何をどこに置くか

Linear Memoryは「ただの配列」なので、**誰が何をどこに置くか**は自分たちで決める必要がある。

### 現状のレイアウト

```
Linear Memory (128MB)
│
│ オフセット
│    ↓
│    0         65536       900000      1000000                    47080000
│    │           │           │           │                           │
▼    ▼           ▼           ▼           ▼                           ▼
┌────┬───────────┬───────────┬───────────┬───────────────────────────┬─────┐
│    │           │           │           │                           │     │
│ A  │     B     │     C     │     D     │            E              │ 空き│
│    │           │           │           │                           │     │
└────┴───────────┴───────────┴───────────┴───────────────────────────┴─────┘

A: MoonBit Stack (64KB)
   - MoonBitの関数呼び出しで使う一時領域
   - MoonBitコンパイラが自動管理

B: MoonBit Heap (~834KB)
   - MoonBitの FixedArray, Ref, struct などが置かれる
   - MoonBitコンパイラが自動管理
   - 現状: sample_buffer_0 ~ sample_buffer_7 がここに居る (46MB!)

C: Audio I/O Buffers (数KB)
   - processBlock で使う入出力バッファ
   - C++/JSが「ここを使う」と決めた

D: Sample Data Region (46MB)
   - サンプルの生データ (PCM)
   - C++/JSが「ここを使う」と決めた
   - SAMPLE_DATA_START = 1000000 から始まる

E: 空き領域
```

---

## 3. なぜ B と D に同じデータがあるのか

ここが現状の問題点。

### 現状のデータフロー (loadSample時)

```
Step 1: C++/JSがサンプルデータを受け取る
        ┌─────────────────┐
        │ PCMデータ       │
        │ (ユーザーの     │
        │  音声ファイル)  │
        └────────┬────────┘
                 │
                 ▼
Step 2: C++/JSがLinear MemoryのD領域に書き込む
        ┌─────────────────────────────────────────────────┐
        │ Linear Memory                                    │
        │                                                  │
        │  ... │ B: MoonBit Heap │ ... │ D: Sample Data │ │
        │      │                 │     │ ← ここに書く   │ │
        └─────────────────────────────────────────────────┘
                 │
                 │  wasm.load_sample(slot, offset, length) を呼ぶ
                 ▼
Step 3: MoonBitがD領域から読んで、B領域にコピー (!?)
        ┌─────────────────────────────────────────────────┐
        │ Linear Memory                                    │
        │                                                  │
        │  ... │ B: MoonBit Heap │ ... │ D: Sample Data │ │
        │      │ ↑ ここにコピー │     │ ← ここから読む │ │
        │      │   (FixedArray) │     │                 │ │
        └─────────────────────────────────────────────────┘
```

**なぜこうなっているか:**

1. **C++/JS** は MoonBit Heap の構造を知らない
   - 「MoonBitのFixedArrayってメモリのどこ?」→ わからない
   - だから自分で決めた場所 (D領域) に書く

2. **MoonBit** は D領域の存在を知らなかった (設計時)
   - 「データはFixedArrayに入れるもの」という前提で書かれた
   - だからD領域からコピーしてくる

**結果: 同じデータが2箇所に存在 = メモリの無駄**

---

## 4. 解決策: MoonBitがD領域を直接読む

### 新しいアプローチ

MoonBitは「自分のバッファにコピー」をやめて、「D領域を直接読む」ようにする:

```
Step 1: C++/JSがサンプルデータを受け取る (同じ)

Step 2: C++/JSがD領域に書き込む (同じ)
        ┌─────────────────────────────────────────────────┐
        │ Linear Memory                                    │
        │                                                  │
        │  ... │ B: MoonBit Heap │ ... │ D: Sample Data │ │
        │      │ (ほぼ空)        │     │ ← ここに書く   │ │
        └─────────────────────────────────────────────────┘
                 │
                 │  wasm.load_sample(slot, offset, length) を呼ぶ
                 ▼
Step 3: MoonBitは「どこにあるか」だけ覚える (コピーしない!)
        ┌─────────────────────────────────────────────────┐
        │ Linear Memory                                    │
        │                                                  │
        │  ... │ B: MoonBit Heap │ ... │ D: Sample Data │ │
        │      │ slot.data_ptr ──────────→ ここを指す   │ │
        │      │ slot.length = 48000     │                 │ │
        │      │ (数十バイト)    │     │                 │ │
        └─────────────────────────────────────────────────┘

Step 4: 再生時、MoonBitはD領域から直接読む
        ┌─────────────────────────────────────────────────┐
        │ Linear Memory                                    │
        │                                                  │
        │  ... │ B: MoonBit Heap │ ... │ D: Sample Data │ │
        │      │ slot.data_ptr ──────────→ 直接読む!    │ │
        └─────────────────────────────────────────────────┘
```

**効果:**
- B領域のサイズ: 46MB → 数百バイト
- データは1箇所だけ (D領域)

---

## 5. スロット数・長さを動的にするには

### 現状の制限

D領域は「8スロット × 30秒分」で固定されている:

```
D領域 (SAMPLE_DATA_START = 1000000 から)
│
├── Slot 0: オフセット 0      ～ 5759999  (5.76MB固定)
├── Slot 1: オフセット 5760000 ～ 11519999 (5.76MB固定)
├── Slot 2: オフセット 11520000 ～ ...
│   ...
└── Slot 7: オフセット 40320000 ～ 46079999 (5.76MB固定)

問題:
- 1秒の音声でも5.76MB使う (無駄)
- 9個目のスロットは作れない
- 31秒の音声は入らない
```

### 動的にする方法

**考え方: 「次の空き位置」を覚えておいて、必要な分だけ使う**

```
最初の状態:
┌────────────────────────────────────────────────────────────────────┐
│ D領域                                                              │
│                                                                    │
│ [空き空き空き空き空き空き空き空き空き空き空き空き空き空き空き...] │
│ ↑                                                                  │
│ nextFreeOffset = 0                                                 │
└────────────────────────────────────────────────────────────────────┘

1秒のサンプルをロード (48000サンプル = 192KB):
┌────────────────────────────────────────────────────────────────────┐
│ D領域                                                              │
│                                                                    │
│ [Slot 0 (192KB)][空き空き空き空き空き空き空き空き空き空き空き...] │
│                 ↑                                                  │
│                 nextFreeOffset = 192000                            │
└────────────────────────────────────────────────────────────────────┘
  MoonBit: slots[0] = { data_ptr: 1000000, length: 48000, ... }

5秒のサンプルをロード (240000サンプル = 960KB):
┌────────────────────────────────────────────────────────────────────┐
│ D領域                                                              │
│                                                                    │
│ [Slot 0 (192KB)][Slot 1 (960KB)][空き空き空き空き空き空き空き...] │
│                                 ↑                                  │
│                                 nextFreeOffset = 1152000           │
└────────────────────────────────────────────────────────────────────┘
  MoonBit: slots[1] = { data_ptr: 1192000, length: 240000, ... }

10秒のサンプルをロード:
┌────────────────────────────────────────────────────────────────────┐
│ D領域                                                              │
│                                                                    │
│ [Slot 0][Slot 1][Slot 2 (1.92MB)][空き空き空き空き空き...        ]│
│                                   ↑                                │
│                                   nextFreeOffset = 3072000         │
└────────────────────────────────────────────────────────────────────┘
  MoonBit: slots[2] = { data_ptr: 2152000, length: 480000, ... }
```

**誰が `nextFreeOffset` を管理するか? → Host (C++/JS)**

理由:
- HostがD領域に書き込む
- Hostが「どこに書いたか」を知っている
- MoonBitに「ここに書いたよ」と教えればいい

---

## 6. 変更が必要な箇所

### C++ (Host側)

**Before:**
```cpp
// 固定オフセット計算
uint32_t slotOffset = slot * MAX_SAMPLES_PER_SLOT;  // slot * 1440000
```

**After:**
```cpp
// 動的オフセット管理
uint32_t nextFreeOffset_ = 0;

int loadSample(const float* data, int length) {
    uint32_t offset = SAMPLE_DATA_START + nextFreeOffset_;
    std::memcpy(memBase + offset, data, length * sizeof(float));
    
    int slotId = /* 新しいスロットID */;
    wasm_call(load_sample, slotId, offset, length);
    
    nextFreeOffset_ += length * sizeof(float);
    return slotId;
}
```

### JS (Host側)

同様の変更。

### MoonBit (WASM側)

**Before:**
```rust
// 46MB の固定バッファ
let sample_buffer_0 : FixedArray[Float] = FixedArray::make(1440000, 0.0)
// ... x8

pub fn load_sample(slot, data_ptr, length) {
    // D領域からB領域にコピー (無駄!)
    for i in 0..length {
        sample_buffer_N[i] = read_from_linear_memory(data_ptr + i*4)
    }
}
```

**After:**
```rust
// ポインタだけ覚える (数バイト)
struct SlotMeta {
    mut data_ptr : Int,  // D領域内のオフセット
    mut length : Int,
    mut play_pos : Int,
    mut playing : Int,
}

let slots : Array[SlotMeta] = []  // 動的配列

pub fn load_sample(slot_id, data_ptr, length) {
    // ポインタを記録するだけ (コピーしない!)
    slots[slot_id].data_ptr = data_ptr
    slots[slot_id].length = length
}

pub fn process_sampler_stereo() {
    for slot in slots {
        if slot.playing {
            // D領域から直接読む
            let sample = read_from_linear_memory(slot.data_ptr + slot.play_pos * 4)
            // ...
        }
    }
}
```

---

## 7. まとめ

| 項目 | 現状 | 改善後 |
|------|------|--------|
| データの場所 | B領域 + D領域 (2箇所) | D領域のみ (1箇所) |
| MoonBitの役割 | データをコピーして保持 | ポインタで参照 |
| スロット数 | 8固定 | 無制限 |
| サンプル長 | 30秒固定 | 無制限 |
| メモリ使用量 | 92MB (大部分が無駄) | 実際のサンプル分だけ |
| メモリ管理者 | なし (全部固定) | Host (C++/JS) |

---

## 用語集

| 用語 | 意味 |
|------|------|
| Linear Memory | WASMモジュールとHostが共有する1本のバイト配列 |
| オフセット | Linear Memory内の位置 (配列のインデックス) |
| MoonBit Heap | MoonBitが自分のデータ構造を置く領域 |
| D領域 / Sample Data Region | Hostがサンプルデータを置く領域 |
| Host | WASMを呼び出す側 (C++ / JavaScript) |
